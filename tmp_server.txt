#!/usr/bin/env python3
import json
import os
import sqlite3
import threading
from datetime import datetime
from http import HTTPStatus
from http.server import SimpleHTTPRequestHandler, ThreadingHTTPServer
import re
from urllib.parse import urlparse

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
PUBLIC_DIR = os.path.join(BASE_DIR, "public")
DB_PATH = os.path.join(BASE_DIR, "site.db")
ADMIN_TOKEN = os.environ.get("ADMIN_TOKEN", "admin123")


def init_db():
    con = sqlite3.connect(DB_PATH)
    try:
        con.execute(
            """
            CREATE TABLE IF NOT EXISTS messages (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT NOT NULL,
              text TEXT NOT NULL,
              created_at TEXT NOT NULL
            )
            """
        )
        con.execute(
            """
            CREATE TABLE IF NOT EXISTS projects (
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              title TEXT NOT NULL,
              username TEXT NOT NULL,
              fullname TEXT NOT NULL,
              repo_url TEXT NOT NULL,
              created_at TEXT NOT NULL
            )
            """
        )
        con.commit()
    finally:
        con.close()


DB_LOCK = threading.Lock()


class AppHandler(SimpleHTTPRequestHandler):
    # Обслуживаем статику из public
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=PUBLIC_DIR, **kwargs)

    # Упрощённые CORS для API (на будущее)
    def _set_cors(self):
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Access-Control-Allow-Headers", "*, Content-Type")
        self.send_header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")

    def _is_admin(self):
        if not ADMIN_TOKEN:
            return True
        header = self.headers.get("X-Admin-Token") or self.headers.get("Authorization", "")
        token = header.replace("Bearer", "").strip()
        return token == ADMIN_TOKEN

    def _require_admin(self):
        if not self._is_admin():
            self.send_response(HTTPStatus.UNAUTHORIZED)
            self._set_cors()
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(json.dumps({"error": "admin token required"}).encode("utf-8"))
            return False
        return True

    def do_OPTIONS(self):
        if self.path.startswith("/api/"):
            self.send_response(HTTPStatus.NO_CONTENT)
            self._set_cors()
            self.end_headers()
        else:
            super().do_OPTIONS()

    def do_GET(self):
        if self.path.startswith("/api/"):
            self.handle_api_get()
            return
        # Статика
        super().do_GET()

    def do_POST(self):
        if self.path.startswith("/api/"):
            self.handle_api_post()
            return
        self.send_error(HTTPStatus.NOT_FOUND, "Not Found")

    def do_PUT(self):
        if self.path.startswith("/api/"):
            self.handle_api_put()
            return
        self.send_error(HTTPStatus.NOT_FOUND, "Not Found")

    def do_DELETE(self):
        if self.path.startswith("/api/"):
            self.handle_api_delete()
            return
        self.send_error(HTTPStatus.NOT_FOUND, "Not Found")

    # ---- API ----
    def handle_api_get(self):
        parsed = urlparse(self.path)
        if parsed.path == "/api/health":
            self.send_response(HTTPStatus.OK)
            self._set_cors()
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(json.dumps({"status": "ok"}).encode("utf-8"))
            return

        if parsed.path == "/api/messages":
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                con.row_factory = sqlite3.Row
                cur = con.execute(
                    "SELECT id, name, text, created_at FROM messages ORDER BY id DESC LIMIT 200"
                )
                rows = [dict(r) for r in cur.fetchall()]
            self.send_response(HTTPStatus.OK)
            self._set_cors()
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(json.dumps(rows).encode("utf-8"))
            return

        if parsed.path == "/api/projects" or parsed.path == "/api/projects/":
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                con.row_factory = sqlite3.Row
                cur = con.execute(
                    "SELECT id, title, username, fullname, repo_url, created_at FROM projects ORDER BY id DESC"
                )
                rows = [dict(r) for r in cur.fetchall()]
            self.send_response(HTTPStatus.OK)
            self._set_cors()
            self.send_header("Content-Type", "application/json; charset=utf-8")
            self.end_headers()
            self.wfile.write(json.dumps(rows).encode("utf-8"))
            return

        self.send_error(HTTPStatus.NOT_FOUND, "Unknown API endpoint")

    def handle_api_post(self):
        parsed = urlparse(self.path)
        length = int(self.headers.get("Content-Length", "0") or 0)
        body = self.rfile.read(length) if length > 0 else b"{}"
        try:
            data = json.loads(body.decode("utf-8"))
        except Exception:
            data = {}

        if parsed.path == "/api/messages":
            name = (data.get("name") or "Гость").strip()[:100]
            text = (data.get("text") or "").strip()[:2000]
            if not text:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "text is required"})
            created_at = datetime.utcnow().isoformat() + "Z"
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                con.execute(
                    "INSERT INTO messages(name, text, created_at) VALUES(?,?,?)",
                    (name, text, created_at),
                )
                con.commit()
            return self._send_json(HTTPStatus.CREATED, {"ok": True})

        if parsed.path == "/api/projects":
            title = (data.get("title") or "").strip()[:150]
            username = (data.get("username") or "").strip()[:100]
            fullname = (data.get("fullname") or "").strip()[:150]
            repo_url = (data.get("repo_url") or "").strip()
            if not title or not username or not fullname or not repo_url:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "Все поля обязательны"})
            if not re.fullmatch(r"[A-Za-z0-9-]{1,39}", username):
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "Некорректный GitHub ник"})
            if not repo_url.startswith("https://github.com/"):
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "Ссылка должна вести на GitHub"})
            tail = repo_url[len("https://github.com/"):]
            parts = tail.split("/")
            if len(parts) < 2 or not parts[0] or not parts[1]:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "Формат ссылки: https://github.com/owner/repo"})
            created_at = datetime.utcnow().isoformat() + "Z"
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                cur = con.execute(
                    "INSERT INTO projects(title, username, fullname, repo_url, created_at) VALUES(?,?,?,?,?)",
                    (title, username, fullname, repo_url, created_at)
                )
                project_id = cur.lastrowid
                con.commit()
            return self._send_json(HTTPStatus.CREATED, {
                "ok": True,
                "project": {
                    "id": project_id,
                    "title": title,
                    "username": username,
                    "fullname": fullname,
                    "repo_url": repo_url,
                    "created_at": created_at
                }
            })

        self.send_error(HTTPStatus.NOT_FOUND, "Unknown API endpoint")

    def handle_api_put(self):
        parsed = urlparse(self.path)
        if parsed.path.startswith("/api/messages/"):
            if not self._require_admin():
                return
            try:
                msg_id = int(parsed.path.rsplit("/", 1)[-1])
            except ValueError:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "invalid id"})
            length = int(self.headers.get("Content-Length", "0") or 0)
            body = self.rfile.read(length) if length > 0 else b"{}"
            try:
                data = json.loads(body.decode("utf-8"))
            except Exception:
                data = {}
            name = (data.get("name") or "Гость").strip()[:100]
            text = (data.get("text") or "").strip()[:2000]
            if not text:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "text is required"})
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                cur = con.execute("UPDATE messages SET name=?, text=? WHERE id=?", (name, text, msg_id))
                con.commit()
                if cur.rowcount == 0:
                    return self._send_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
            return self._send_json(HTTPStatus.OK, {"ok": True})

        if parsed.path.startswith("/api/projects/"):
            if not self._require_admin():
                return
            try:
                project_id = int(parsed.path.rsplit("/", 1)[-1])
            except ValueError:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "invalid id"})
            length = int(self.headers.get("Content-Length", "0") or 0)
            body = self.rfile.read(length) if length > 0 else b"{}"
            try:
                data = json.loads(body.decode("utf-8"))
            except Exception:
                data = {}
            title = (data.get("title") or "").strip()[:150]
            fullname = (data.get("fullname") or "").strip()[:150]
            repo_url = (data.get("repo_url") or "").strip()
            if not title or not fullname or not repo_url:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "Все поля обязательны"})
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                cur = con.execute(
                    "UPDATE projects SET title=?, fullname=?, repo_url=? WHERE id=?",
                    (title, fullname, repo_url, project_id)
                )
                con.commit()
                if cur.rowcount == 0:
                    return self._send_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
            return self._send_json(HTTPStatus.OK, {"ok": True})

        self.send_error(HTTPStatus.NOT_FOUND, "Unknown API endpoint")

    def handle_api_delete(self):
        parsed = urlparse(self.path)
        if parsed.path.startswith("/api/messages/"):
            if not self._require_admin():
                return
            try:
                msg_id = int(parsed.path.rsplit("/", 1)[-1])
            except ValueError:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "invalid id"})
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                cur = con.execute("DELETE FROM messages WHERE id=?", (msg_id,))
                con.commit()
                if cur.rowcount == 0:
                    return self._send_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
            return self._send_json(HTTPStatus.OK, {"ok": True})

        if parsed.path.startswith("/api/projects/"):
            if not self._require_admin():
                return
            try:
                project_id = int(parsed.path.rsplit("/", 1)[-1])
            except ValueError:
                return self._send_json(HTTPStatus.BAD_REQUEST, {"error": "invalid id"})
            with DB_LOCK, sqlite3.connect(DB_PATH) as con:
                cur = con.execute("DELETE FROM projects WHERE id=?", (project_id,))
                con.commit()
                if cur.rowcount == 0:
                    return self._send_json(HTTPStatus.NOT_FOUND, {"error": "not found"})
            return self._send_json(HTTPStatus.OK, {"ok": True})

        self.send_error(HTTPStatus.NOT_FOUND, "Unknown API endpoint")

    def _send_json(self, status, payload):
        self.send_response(status)
        self._set_cors()
        self.send_header("Content-Type", "application/json; charset=utf-8")
        self.end_headers()
        self.wfile.write(json.dumps(payload).encode("utf-8"))

def run():
    init_db()
    host = os.environ.get("HOST", "0.0.0.0")
    port = int(os.environ.get("PORT", "8080"))
    server = ThreadingHTTPServer((host, port), AppHandler)
    print(f"Server running on http://{host}:{port}")
    print(f"Static: {PUBLIC_DIR}")
    print(f"DB: {DB_PATH}")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down...")
    finally:
        server.server_close()


if __name__ == "__main__":
    run()


